import { expect, test } from 'bun:test'
import zws from '../index'

test('Buffer overflow attack with extremely long Unicode sequences', () => {
  const normalText = 'Standard medical procedure'
  const overflowPayload = 'A'.repeat(100000)

  // System should reject oversized payloads
  expect(() => {
    zws.encodeData(overflowPayload)
  }).toThrow('Data too long')

  // System should safely return original text when embed fails
  const result = zws.embed(normalText, overflowPayload)
  expect(result).toBe(normalText)
})

test('Memory exhaustion through massive encoded strings', () => {
  const massiveString = '🏥'.repeat(50000)

  // System should reject invalid Unicode characters and oversized payloads
  expect(() => {
    zws.encodeData(massiveString)
  }).toThrow()
})

test('Unicode normalization bypass attacks', () => {
  const normalizedText = 'café'
  const decomposedText = 'cafe\u0301'

  const payload1 = zws.embed('Medical instruction', normalizedText)
  const payload2 = zws.embed('Medical instruction', decomposedText)

  expect(zws.extract(payload1)).toBe(normalizedText)
  expect(zws.extract(payload2)).toBe(decomposedText)
  expect(zws.extract(payload1)).not.toBe(zws.extract(payload2))
})

test('Null byte injection in medical records', () => {
  const nullByteAttack = "Safe content\x00<script>alert('xss')</script>"
  const medicalRecord = 'Patient chart for review'

  const weaponized = zws.embed(medicalRecord, nullByteAttack)
  const extracted = zws.extract(weaponized)

  expect(extracted).toBe(nullByteAttack)
  expect(extracted).toContain('\x00')
  expect(extracted).toContain('<script>')
})

test('Surrogate pair manipulation attacks', () => {
  const highSurrogate = '\uD800'
  const lowSurrogate = '\uDC00'
  const surrogateAttack = highSurrogate + lowSurrogate + 'malicious'

  // System should reject invalid Unicode characters
  expect(() => {
    zws.encodeData(surrogateAttack)
  }).toThrow('Invalid character in data')
})

test('Character encoding attack through mixed encodings', () => {
  const mixedEncodingAttack = 'Normal\uFEFFhidden\u200B\u200Cmalicious\uFFFE'
  const instruction = 'Take medication as prescribed'

  const weaponized = zws.embed(instruction, mixedEncodingAttack)
  const extracted = zws.extract(weaponized)

  expect(extracted).toBe(mixedEncodingAttack)
  expect(extracted).toContain('\uFEFF')
  expect(extracted).toContain('\uFFFE')
})

test('Control character injection attack', () => {
  const controlChars =
    '\x01\x02\x03\x04\x05\x06\x07\x08\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F'
  const medicalNote = 'Patient vital signs recorded'

  const weaponized = zws.embed(medicalNote, controlChars)
  const extracted = zws.extract(weaponized)

  expect(extracted).toBe(controlChars)
  expect(extracted).toHaveLength(26)
})

test('Unicode bidirectional override attack', () => {
  const bidiAttack = 'safe\u202Egnissecorp\u202Dmalicious'
  const procedure = 'Standard operating procedure'

  const weaponized = zws.embed(procedure, bidiAttack)
  const extracted = zws.extract(weaponized)

  expect(extracted).toBe(bidiAttack)
  expect(extracted).toContain('\u202E')
  expect(extracted).toContain('\u202D')
})

test('Zero-width character collision attack', () => {
  const collisionText = '\u200B\u200C\u200D\u200E\u200F\uFEFF'
  const medicalData = 'Lab results summary'

  const weaponized = zws.embed(medicalData, collisionText)
  const extracted = zws.extract(weaponized)

  expect(extracted).toBe(collisionText)
  expect(extracted).toContain('\u200D')
  expect(extracted).toContain('\u200E')
  expect(extracted).toContain('\u200F')
})

test('Homoglyph character replacement attack', () => {
  const homoglyphAttack = 'Аdmin'
  const realText = 'Admin'
  const instruction = 'Administrator access required'

  const weaponized = zws.embed(instruction, homoglyphAttack)
  const extracted = zws.extract(weaponized)

  expect(extracted).toBe(homoglyphAttack)
  expect(extracted).not.toBe(realText)
  expect(extracted.charCodeAt(0)).not.toBe(realText.charCodeAt(0))
})

test('Stack overflow through recursive encoding', () => {
  let nestedText = 'base'

  for (let i = 0; i < 100; i++) {
    nestedText = zws.embed(nestedText, `level-${i}`)
  }

  expect(nestedText).toContain('base')
  expect(() => zws.getCleanText(nestedText)).not.toThrow()
})

test('Performance DoS through complex Unicode patterns', () => {
  const complexPattern = '\u0300\u0301\u0302\u0303\u0304'.repeat(1000)
  const baseText = 'a'.repeat(1000)
  const combinedAttack = baseText + complexPattern

  // System should reject oversized payloads before processing
  expect(() => {
    zws.encodeData(combinedAttack)
  }).toThrow('Data too long')
})

test('Memory leak through unclosed Unicode sequences', () => {
  const openSequences = '\u0300\u0301\u0302'
  const baseChars = 'abcdefghijklmnopqrstuvwxyz'.repeat(100)
  const leakTest = baseChars + openSequences

  // System should reject oversized payloads
  expect(() => {
    zws.encodeData(leakTest)
  }).toThrow('Data too long')
})
